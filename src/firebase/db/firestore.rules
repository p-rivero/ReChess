rules_version = '2';

// Unless otherwise specified, top-level documents are publically readable by anyone,
// and only the owner can write to them. The subcollection "private" is only readable
// and writable by the owner.
// If a document contains the field "IMMUTABLE", then all writes attempting to modify
// that field will be rejected. This field contains data that can be read by anyone
// with read access to the document, but can only be modified by a server-side function.

// See schema.d.ts for the database schema


// HELPER FUNCTIONS

// Returns true if the user is authenticated and has the given id
function isAuth(id) {
  return isAuthUnverified(id) && request.auth.token.email_verified;
}
// Same as isAuth, but does not require the email to be verified
function isAuthUnverified(id) {
  return request.auth != null && request.auth.uid != null && request.auth.uid == id;
}

// Checks that two maps are equal
function mapEq(mapA, mapB) {
  return mapA.diff(mapB).affectedKeys().size() == 0;
}
// Checks that the given field is null or equal to the given value
function nullOrEq(nullable, val) {
  return nullable == null || nullable == val;
}

// Checks that the request contains all the required fields and no extra extra fields
function hasCorrectFields(required, optional) {
  let allowed = required.concat(optional);
  return request.resource.data.keys().hasAll(required) && request.resource.data.keys().hasOnly(allowed);
}
// Same as hasCorrectFields, but checks the IMMUTABLE field
function hasCorrectImmutableFields(required, optional) {
  let allowed = required.concat(optional);
  return request.resource.data.IMMUTABLE.keys().hasAll(required) && request.resource.data.IMMUTABLE.keys().hasOnly(allowed);
}
// Checks that the IMMUTABLE field has not changed
function immutableOk() {
  return mapEq(request.resource.data.IMMUTABLE, resource.data.IMMUTABLE);
}


service cloud.firestore {
  match /databases/{database}/documents {
    
    function usernameIsTaken(username) {
      return exists(/databases/$(database)/documents/usernames/$(username));
    }
    function isValidUsername(username) {
      return username.size() >= 3 &&
        username.size() <= 25 &&
        username.matches('^[a-zA-Z0-9_]+$');
    }
    
    
    match /usernames/{username} {
      allow read;
      allow create: if
        // When creating a user, the user must be authenticated and the starting data must be correct. Allow unverified accounts, since at the time of creation, the user has not yet verified their email.
        isAuthUnverified(request.resource.data.userId) &&
        isValidUsername(username) &&
        !usernameIsTaken(username) &&
        // Username must be registered batched with a user document
        getAfter(/databases/$(database)/documents/users/$(request.resource.data.userId)).data.IMMUTABLE.username == username;
      
      allow update: if false;
      
      // Disallow deleting usernames for now
      allow delete: if false;
    }
    
    match /users/{userId} {
      
      function isUserDoc() {
        return hasCorrectFields(['about', 'IMMUTABLE'], ['name', 'profileImg']) &&
          hasCorrectImmutableFields(['username', 'numWins'], []);
      }
      function isPrivateUserDoc() {
        return hasCorrectFields(['IMMUTABLE'], []) &&
          hasCorrectImmutableFields(['email', 'banned'], []);
      }
      
      allow read;
      allow update: if isUserDoc() && isAuth(userId) && immutableOk();
      
      allow create: if
        isUserDoc() &&
        isAuthUnverified(userId) &&
        nullOrEq(request.resource.data.name, request.auth.token.name) &&
        request.resource.data.about == '' &&
        nullOrEq(request.resource.data.profileImg, request.auth.token.picture) &&
        // Username is correct and not taken
        isValidUsername(request.resource.data.IMMUTABLE.username) &&
        !usernameIsTaken(request.resource.data.IMMUTABLE.username) &&
        request.resource.data.IMMUTABLE.numWins == 0 &&
        // Username must be registered batched with a user document
        getAfter(/databases/$(database)/documents/usernames/$(request.resource.data.IMMUTABLE.username)).data.userId == userId;
        
      // Disallow deleting users for now
      allow delete: if false;
      
      
      match /private/{doc} {
        allow read: if isAuth(userId);
        allow update: if isPrivateUserDoc() && isAuth(userId) && immutableOk();
          
        allow create: if
          isPrivateUserDoc() &&
          isAuthUnverified(userId) &&
          request.resource.data.IMMUTABLE.email == request.auth.token.email &&
          request.resource.data.IMMUTABLE.banned == false;
        
        allow delete: if false;
      }
    }
    
    
    match /variants/{variantId} {
      function isVariantDoc() {
        return hasCorrectFields(['name', 'description', 'IMMUTABLE'], []) &&
          hasCorrectImmutableFields(['creatorDisplayName', 'creatorId', 'numUpvotes', 'initialState'], []);
      }
      function isValidVariant(variant) {
        let userDoc = getAfter(/databases/$(database)/documents/users/$(variant.IMMUTABLE.creatorId));
        let expectedDisplayName = userDoc.data.name == null ? '@' + userDoc.data.IMMUTABLE.username : userDoc.data.name;
        return isVariantDoc() &&
          variant.name.size() >= 3 &&
          variant.name.size() <= 50 &&
          variant.description.size() <= 500 &&
          variant.IMMUTABLE.creatorDisplayName == expectedDisplayName &&
          isAuth(variant.IMMUTABLE.creatorId) &&
          variant.IMMUTABLE.numUpvotes == 0 &&
          variant.IMMUTABLE.initialState.size() <= 100000;
      }
      
      allow read;
      // Create if authenticated, update if authenticated and existing creator
      allow create: if isValidVariant(request.resource.data);
      allow update: if isAuth(resource.data.creatorId) && isValidVariant(request.resource.data) && immutableOk();
      // Disallow deleting variants
      allow delete: if false;
    }
    
  }
}
