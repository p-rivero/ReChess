rules_version = '2';

// Unless otherwise specified, top-level documents are publically readable by anyone,
// and only the owner can write to them. The subcollection "private" is only readable
// and writable by the owner.
// If a document contains the field "IMMUTABLE", then all writes attempting to modify
// that field will be rejected. This field contains data that can be read by anyone
// with read access to the document, but can only be modified by a server-side function.

// See ./schema.d.ts for the database schema
// See test/firebase/firestore.spec.ts for tests


// HELPER FUNCTIONS

// Returns true if the user is authenticated and has the given id
function isAuth(id) {
  return isAuthUnverified(id) && request.auth.token.email_verified;
}
// Same as isAuth, but does not require the email to be verified
function isAuthUnverified(id) {
  return request.auth != null && request.auth.uid != null && request.auth.uid == id;
}

// Checks that two maps are equal
function mapEq(mapA, mapB) {
  return mapA.diff(mapB).affectedKeys().size() == 0;
}

// Checks that a field was created with serverTimestamp()
function correctTimestamp(field) {
  return field == request.time;
}

// Checks that the request contains all the required fields and no extra extra fields
function hasCorrectFields(required, optional) {
  let allowed = required.concat(optional);
  return request.resource.data.keys().hasAll(required) && request.resource.data.keys().hasOnly(allowed);
}
// Same as hasCorrectFields, but checks the IMMUTABLE field
function hasCorrectImmutableFields(required, optional) {
  let allowed = required.concat(optional);
  return request.resource.data.IMMUTABLE.keys().hasAll(required) && request.resource.data.IMMUTABLE.keys().hasOnly(allowed);
}
// Checks that the IMMUTABLE field has not changed
function immutableOk() {
  return mapEq(request.resource.data.IMMUTABLE, resource.data.IMMUTABLE);
}

// Prints the input to the debug log and returns true
// function print(msg) {
//   return debug(msg) || true;
// }


service cloud.firestore {
  match /databases/{database}/documents {
    
    function usernameIsTaken(username) {
      return exists(/databases/$(database)/documents/usernames/$(username));
    }
    function isValidUsername(username) {
      return username.size() >= 3 &&
        username.size() <= 25 &&
        username.matches('^[a-zA-Z0-9_]+$');
    }
    
    
    match /usernames/{username} {
      allow read;
      allow create: if
        // When creating a user, the user must be authenticated and the starting data must be correct. Allow unverified accounts, since at the time of creation, the user has not yet verified their email.
        isAuthUnverified(request.resource.data.userId) &&
        isValidUsername(username) &&
        !usernameIsTaken(username) &&
        // Username must be registered batched with a user document
        getAfter(/databases/$(database)/documents/users/$(request.resource.data.userId)).data.IMMUTABLE.username == username;
      
      allow update: if false;
      
      // Disallow deleting usernames for now
      allow delete: if false;
    }
    
    
    match /users/{userId} {
      
      function isUserDoc() {
        return hasCorrectFields(['about', 'IMMUTABLE'], ['name', 'profileImg']) &&
          hasCorrectImmutableFields(['username', 'numWins'], ['renameAllowedAt']) &&
          request.resource.data.about.size() <= 1000 &&
          (request.resource.data.name == null ||
            (request.resource.data.name.size() <= 50 && request.resource.data.name.size() > 0)) &&
          (request.resource.data.profileImg == null ||
            request.resource.data.profileImg.size() <= 600);
      }
      function isPrivateUserDoc() {
        return hasCorrectFields(['IMMUTABLE'], []) &&
          hasCorrectImmutableFields(['email', 'banned'], []) &&
          request.resource.data.IMMUTABLE.email.size() <= 200;
      }
      function invalidNameChange() {
        return // The name change is invalid if
          // The name changed
          request.resource.data.name != resource.data.name &&
          // renameAllowedAt is set (the user has already changed their name once)
          request.resource.data.IMMUTABLE.renameAllowedAt != null &&
          // renameAllowedAt is in the future (the user cannot change their name yet)
          request.resource.data.IMMUTABLE.renameAllowedAt > request.time;
      }
      
      
      allow read;
      allow update: if 
        isUserDoc() &&
        isAuth(userId) &&
        immutableOk() &&
        !invalidNameChange();
      
      allow create: if
        isUserDoc() &&
        isAuthUnverified(userId) &&
        // Username is correct and not taken
        isValidUsername(request.resource.data.IMMUTABLE.username) &&
        !usernameIsTaken(request.resource.data.IMMUTABLE.username) &&
        request.resource.data.IMMUTABLE.numWins == 0 &&
        request.resource.data.IMMUTABLE.renameAllowedAt == null &&
        // User must be created in a batch with a username document
        getAfter(/databases/$(database)/documents/usernames/$(request.resource.data.IMMUTABLE.username)).data.userId == userId &&
        // User must be created in a batch with a private document
        existsAfter(/databases/$(database)/documents/users/$(userId)/private/doc);
        
      // Disallow deleting users for now
      allow delete: if false;
      
      
      match /private/{doc} {
        allow read: if isAuth(userId);
        allow update: if 
          immutableOk() &&
          isPrivateUserDoc() &&
          isAuth(userId);
          
        allow create: if
          isPrivateUserDoc() &&
          isAuthUnverified(userId) &&
          doc == 'doc' && // Only 1 document allowed
          request.resource.data.IMMUTABLE.email == request.auth.token.email &&
          request.resource.data.IMMUTABLE.banned == false;
        
        allow delete: if false;
      }
      
      match /upvotedVariants/{variantId} {
        function assertUpvoteDelta(delta) {
          let docBefore = get(/databases/$(database)/documents/variants/$(variantId)/upvotes/doc);
          let docAfter = getAfter(/databases/$(database)/documents/variants/$(variantId)/upvotes/doc);
          return docAfter.data.numUpvotes == docBefore.data.numUpvotes + delta;
        }
        
        // Other users cannot see my upvotes
        allow read: if isAuth(userId);
        // When creating an upvote, also increment the variant's numUpvotes
        allow create: if
          hasCorrectFields(['timeUpvoted'], []) &&
          isAuth(userId) &&
          correctTimestamp(request.resource.data.timeUpvoted) &&
          assertUpvoteDelta(1);
        // Cannot update an upvote, only delete it
        allow update: if false;
        // When deleting an upvote, also decrement the variant's numUpvotes
        allow delete: if
          isAuth(userId) &&
          assertUpvoteDelta(-1);
      }
    }
    
    
    
    match /variants/{variantId} {
      function isVariantDoc() {
        return hasCorrectFields(['name', 'description', 'IMMUTABLE'], []) &&
          hasCorrectImmutableFields(['creatorDisplayName', 'initialState'], ['creatorId']);
      }
      function isValidVariantEdit(variant) {
        let userDoc = get(/databases/$(database)/documents/users/$(variant.IMMUTABLE.creatorId));
        let expectedDisplayName = userDoc.data.name == null ? '@' + userDoc.data.IMMUTABLE.username : userDoc.data.name;
        return isVariantDoc() &&
          variant.name.size() >= 3 &&
          variant.name.size() <= 50 &&
          variant.description.size() <= 1000 &&
          variant.IMMUTABLE.creatorDisplayName == expectedDisplayName &&
          // Creator can be null if their account has been deleted (not when creating the variant)
          variant.IMMUTABLE.creatorId != null &&
          isAuth(variant.IMMUTABLE.creatorId) &&
          variant.IMMUTABLE.initialState.size() <= 100000;
      }
      
      allow read;
      // Create if authenticated, update if authenticated and existing creator
      allow create: if
        isValidVariantEdit(request.resource.data) &&
        // Check that there is no leading or trailing whitespace in the name
        request.resource.data.name == request.resource.data.name.trim();
        
      allow update: if
        immutableOk() &&
        isValidVariantEdit(request.resource.data) &&
        isAuth(resource.data.IMMUTABLE.creatorId);
      
      // Disallow deleting variants
      allow delete: if false;
      
      
      match /upvotes/{doc} {
        function isVariantUpvotesDoc() {
          return hasCorrectFields(['numUpvotes'], []);
        }
        function isVariantCreator() {
          let creator = get(/databases/$(database)/documents/variants/$(variantId)).data.IMMUTABLE.creatorId;
          return isAuth(creator);
        }
        function isValidUpvote() {
          // Check that the logged user had not upvoted this variant before
          let userId = request.auth.uid;
          return !exists(/databases/$(database)/documents/users/$(userId)/upvotedVariants/$(variantId)) &&
            existsAfter(/databases/$(database)/documents/users/$(userId)/upvotedVariants/$(variantId));
        }
        function isValidUnUpvote() {
          // Check that the logged user had upvoted this variant before
          let userId = request.auth.uid;
          return exists(/databases/$(database)/documents/users/$(userId)/upvotedVariants/$(variantId)) &&
            !existsAfter(/databases/$(database)/documents/users/$(userId)/upvotedVariants/$(variantId));
        }
        
        allow read;
        // Created once, when making the variant
        allow create: if 
          isVariantUpvotesDoc() &&
          isVariantCreator() &&
          doc == 'doc' && // Only 1 document allowed
          request.resource.data.numUpvotes == 0;
        // Updated when upvoted
        allow update: if
          // Valid increment or decrement
          (request.resource.data.numUpvotes == resource.data.numUpvotes + 1 && isValidUpvote()) ||
          (request.resource.data.numUpvotes == resource.data.numUpvotes - 1 && isValidUnUpvote());
        // Disallow deleting
        allow delete: if false;
      }
    }
    
    // Read-only access to variantIndex
    match /variantIndex/{doc} {
      allow read;
      allow write: if false;
    }
  }
}
