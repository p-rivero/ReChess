rules_version = '2';

// Unless otherwise specified, top-level documents are publically readable by anyone,
// and only the owner can write to them. The subcollection "private" is only readable
// and writable by the owner.
// If a document contains the field "IMMUTABLE", then all writes attempting to modify
// that field will be rejected. This field contains data that can be read by anyone
// with read access to the document, but can only be modified by a server-side function.

// See ./schema.d.ts for the database schema
// See test/firebase/firestore.spec.ts for tests


// HELPER FUNCTIONS

// Returns true if the user is authenticated and has the given id
function loggedAs(id) {
  return loggedAsUnverified(id) && request.auth.token.email_verified;
}
// Same as loggedAs, but does not require the email to be verified
function loggedAsUnverified(id) {
  return request.auth != null && request.auth.uid != null && request.auth.uid == id;
}

// Checks that a field was created with serverTimestamp()
function isServerTimestamp(field) {
  return field == request.time;
}

// Checks that two maps are equal
function mapEq(objA, objB) {
  return objA.diff(objB).affectedKeys().size() == 0;
}
// Checks that a map has all the required fields and no extra extra fields
function hasFields(obj, required, optional) {
  let allowed = required.concat(optional);
  return obj.keys().hasAll(required) && obj.keys().hasOnly(allowed);
}

// Returns true if the input string starts with the given prefix
function startsWith(str, prefix) {
  return str.size() >= prefix.size() && str[0 : prefix.size()] == prefix;
}

// Prints the input to the debug log and returns true
// function print(msg) {
//   return debug(msg) || true;
// }


service cloud.firestore {
  match /databases/{database}/documents {
    
    function usernameIsTaken(username) {
      return exists(/databases/$(database)/documents/usernames/$(username));
    }
    function isValidUsername(username) {
      return
        username.size() >= 3 &&
        username.size() <= 25 &&
        username.matches('^[a-zA-Z0-9_]+$');
    }
    // Returns the expected display name for the given user id
    function expectedDisplayName(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.name == null ? '@' + userDoc.data.IMMUTABLE.username : userDoc.data.name;
    }
    
    
    
    match /usernames/{username} {
      function isUsernameDoc(doc) {
        return
          hasFields(doc, ['userId'], []) &&
          doc.userId is string &&
          doc.userId.size() > 0;
      }
      function allowCreateUsername() {
        let doc = request.resource.data;
        return
          isUsernameDoc(doc) &&
          // When creating a user, the user must be authenticated and the starting data must be correct. Allow unverified accounts, since at the time of creation, the user has not yet verified their email.
          loggedAsUnverified(doc.userId) &&
          isValidUsername(username) &&
          !usernameIsTaken(username) &&
          // Username must be registered batched with a user document
          getAfter(/databases/$(database)/documents/users/$(doc.userId)).data.IMMUTABLE.username == username;
      }
    
      allow read;
      allow create: if allowCreateUsername();
      // Disallow deleting usernames, they are deleted by a cloud function
    }
    
    
    
    match /users/{userId} {
      function isUserDoc(doc) {
        return
          hasFields(doc, ['about', 'IMMUTABLE'], ['name', 'profileImg']) &&
          hasFields(doc.IMMUTABLE, ['username', 'numWins'], ['renameAllowedAt']) &&
          doc.about is string &&
          doc.about.size() <= 1000 &&
          (doc.name == null || (
            doc.name is string &&
            doc.name.size() <= 50 &&
            doc.name.size() > 0 &&
            doc.name == doc.name.trim()
          )) &&
          (doc.profileImg == null || (
            doc.profileImg is string &&
            doc.profileImg.size() <= 600
          )) &&
          doc.IMMUTABLE.username is string &&
          doc.IMMUTABLE.numWins is int &&
          (doc.IMMUTABLE.renameAllowedAt == null || (
            doc.IMMUTABLE.renameAllowedAt is timestamp
          ));
      }
      function allowCreateUser() {
        let doc = request.resource.data;
        return
          isUserDoc(doc) &&
          loggedAsUnverified(userId) &&
          // Username is correct and not taken
          isValidUsername(doc.IMMUTABLE.username) &&
          !usernameIsTaken(doc.IMMUTABLE.username) &&
          doc.IMMUTABLE.numWins == 0 &&
          doc.IMMUTABLE.renameAllowedAt == null &&
          // User must be created in a batch with a username document
          getAfter(/databases/$(database)/documents/usernames/$(doc.IMMUTABLE.username)).data.userId == userId &&
          // User must be created in a batch with a private document
          existsAfter(/databases/$(database)/documents/users/$(userId)/private/doc);
      }
      function allowUpdateUser() {
        let old = resource.data;
        let new = request.resource.data;
        return
          isUserDoc(new) &&
          loggedAs(userId) &&
          mapEq(old.IMMUTABLE, new.IMMUTABLE) &&
          // If the user changed their name, check that they waited long enough
          (old.name != new.name ? (
            old.IMMUTABLE.renameAllowedAt == null ||
            request.time >= old.IMMUTABLE.renameAllowedAt
          ) : true);
      }
      
      allow read;
      allow create: if allowCreateUser();
      allow update: if allowUpdateUser();
      // Disallow deleting users directly, they are deleted by a cloud function
      
      
      match /private/{docName} {
        function isPrivateUserDoc(doc) {
          return
            hasFields(doc, ['IMMUTABLE'], []) &&
            hasFields(doc.IMMUTABLE, ['email', 'banned'], []) &&
            doc.IMMUTABLE.email is string &&
            doc.IMMUTABLE.banned is bool;
        }
        function allowCreateUserPrivate() {
          let doc = request.resource.data;
          return
            isPrivateUserDoc(doc) &&
            loggedAsUnverified(userId) &&
            docName == 'doc' && // Only 1 document allowed
            doc.IMMUTABLE.email == request.auth.token.email &&
            doc.IMMUTABLE.banned == false;
        }
        function allowUpdateUserPrivate() {
          let old = resource.data;
          let new = request.resource.data;
          return
            isPrivateUserDoc(new) &&
            loggedAs(userId) &&
            mapEq(old.IMMUTABLE, new.IMMUTABLE);
        }
        
        allow read: if loggedAs(userId);
        allow create: if allowCreateUserPrivate();
        allow update: if allowUpdateUserPrivate();
      }
      
      
      match /upvotedVariants/{variantId} {
        function isUpvoteDoc(doc) {
          return
            hasFields(doc, ['timeUpvoted'], []) &&
            doc.timeUpvoted is timestamp;
        }
        function allowCreateUpvote() {
          let doc = request.resource.data;
          return
            isUpvoteDoc(doc) &&
            loggedAs(userId) &&
            // User can only upvote a variant once
            isServerTimestamp(doc.timeUpvoted) &&
            exists(/databases/$(database)/documents/variants/$(variantId));
        }
        function allowDeleteUpvote() {
          let doc = resource.data;
          return
            // Fail if the document does not exist, to avoid triggering a cloud function
            isUpvoteDoc(doc) &&
            loggedAs(userId);
        }
        
        // Other users cannot see my upvotes
        allow read: if loggedAs(userId);
        allow create: if allowCreateUpvote();
        allow delete: if allowDeleteUpvote();
      }
    }
    
    
    
    match /variants/{variantId} {
      function isVariantDoc(doc) {
        return
          hasFields(doc, ['name', 'description', 'creationTime', 'creatorDisplayName', 'initialState', 'numUpvotes'], ['creatorId']) &&
          doc.name is string &&
          doc.name.size() >= 3 &&
          doc.name.size() <= 50 &&
          doc.name == doc.name.trim() &&
          doc.description is string &&
          doc.description.size() <= 1000 &&
          doc.creationTime is timestamp &&
          doc.creatorDisplayName is string &&
          doc.initialState is string &&
          doc.initialState.size() <= 100000 &&
          doc.numUpvotes is int &&
          (doc.creatorId == null || doc.creatorId is string);
      }
      function allowCreateVariant() {
        let doc = request.resource.data;
        return
          isVariantDoc(doc) &&
          // Creator can be null if their account has been deleted, but not when creating the variant
          loggedAs(doc.creatorId) &&
          doc.creatorDisplayName == expectedDisplayName(doc.creatorId) &&
          isServerTimestamp(doc.creationTime) &&
          doc.numUpvotes == 0;
      }
      
      allow read;
      allow create: if allowCreateVariant();
      // Disallow editing and deleting variants
      
      
      match /lobby/{creatorUserId} {
        function isLobbyEntryDoc(doc) {
          return
            hasFields(doc, ['IMMUTABLE'], ['challengerId', 'challengerDisplayName', 'gameDocId']) &&
            hasFields(doc.IMMUTABLE, ['creatorId', 'creatorDisplayName', 'timeCreated', 'requestedColor'], []) &&
            doc.IMMUTABLE.creatorId is string &&
            doc.IMMUTABLE.creatorDisplayName is string &&
            doc.IMMUTABLE.timeCreated is timestamp &&
            doc.IMMUTABLE.requestedColor in ['white', 'black', 'random'] &&
            (doc.challengerId == null || doc.challengerId is string) &&
            (doc.challengerDisplayName == null || doc.challengerDisplayName is string) &&
            (doc.gameDocId == null || doc.gameDocId is string);
        }
        function allowCreateLobbyEntry() {
          let doc = request.resource.data;
          return
            isLobbyEntryDoc(doc) &&
            loggedAs(doc.IMMUTABLE.creatorId) &&
            doc.IMMUTABLE.creatorDisplayName == expectedDisplayName(doc.IMMUTABLE.creatorId) &&
            isServerTimestamp(doc.IMMUTABLE.timeCreated) &&
            // Creator initializes the entry with no challenger
            doc.challengerId == null &&
            doc.challengerDisplayName == null &&
            doc.gameDocId == null;
        }
        function allowUpdateLobbyEntry() {
          let old = resource.data;
          let new = request.resource.data;
          return
            isLobbyEntryDoc(new) &&
            mapEq(old.IMMUTABLE, new.IMMUTABLE) &&
            // Challenger clicks "Join"
            ((
              loggedAs(new.challengerId) &&
              old.challengerId == null &&
              old.gameDocId == null &&
              new.challengerId != new.IMMUTABLE.creatorId &&
              new.challengerDisplayName == expectedDisplayName(new.challengerId) &&
              new.gameDocId == null
            )
            // Challenger clicks "Cancel", or creator rejects challenger
            || (
              (loggedAs(old.challengerId) || loggedAs(old.IMMUTABLE.creatorId)) &&
              old.gameDocId == null &&
              new.challengerId == null &&
              new.challengerDisplayName == null &&
              new.gameDocId == null
            )
            // Creator accepts challenger
            || (
              loggedAs(old.IMMUTABLE.creatorId) &&
              old.gameDocId == null &&
              new.gameDocId != null &&
              new.challengerId == old.challengerId &&
              new.challengerDisplayName == old.challengerDisplayName &&
              exists(/databases/$(database)/documents/games/$(new.gameDocId))
            ));
        }
        function allowDeleteLobbyEntry() {
          let doc = resource.data;
          return
            isLobbyEntryDoc(doc) &&
            // Creator cancels the game, OR
            // Challenger acknowledges the created game and clears the entry
            (loggedAs(doc.IMMUTABLE.creatorId) || (
              loggedAs(doc.challengerId) &&
              doc.gameDocId != null
            ));
        }
        
        allow read;
        allow create: if allowCreateLobbyEntry();
        allow update: if allowUpdateLobbyEntry();
        allow delete: if allowDeleteLobbyEntry();
      }
    }
    
    
    
    // Read-only access to variantIndex
    match /variantIndex/{docName} {
      allow read;
    }
    
    
    
    match /games/{gameId} {
      function isGameDoc(doc) {
        let HISTORY_REGEX = '^([a-p][0-9]{1,2}[a-p][0-9]{1,2}(=..?)? )*$';
        return
          hasFields(doc, ['moveHistory', 'playerToMove', 'IMMUTABLE'], ['winner']) &&
          hasFields(doc.IMMUTABLE, ['timeGameStarted', 'variantId', 'variant', 'whiteDisplayName', 'blackDisplayName', 'requestedColor'], ['whiteId', 'blackId']) &&
          doc.moveHistory is string &&
          doc.moveHistory.size() <= 10000 &&
          doc.moveHistory.matches(HISTORY_REGEX) &&
          (doc.winnner == null ? (
            doc.playerToMove in ['white', 'black']
          ) : (
            doc.playerToMove == 'game-over' &&
            doc.winner in ['white', 'black', 'draw']
          ));
          // Don't check immutable fields, they are set by a cloud function
      }
      function allowUpdateGame() {
        let old = resource.data;
        let new = request.resource.data;
        return
          isGameDoc(new) &&
          mapEq(old.IMMUTABLE, new.IMMUTABLE) &&
          // Only allow appending to the move history
          startsWith(new.moveHistory, old.moveHistory) &&
          // Must pass the turn to the other player
          new.playerToMove != old.playerToMove &&
          // Must be logged in as the player whose turn it is
          (old.playerToMove == 'white' && loggedAs(old.IMMUTABLE.whiteId) ||
           old.playerToMove == 'black' && loggedAs(old.IMMUTABLE.blackId));
      }
      
      allow read;
      allow update: if allowUpdateGame();
      // Games can only be created and deleted by cloud functions
    }
    
    
    
    // cancelGame() stores cancelled games here so moderators can review them
    match /cancelledGames/{gameId} {
      // Users cannot read or write to this collection
      allow read: if false;
    }
  }
}
